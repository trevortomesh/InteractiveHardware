{"name":"Interactive Hardware","tagline":"Interactive Hardware (CS 807) ","body":"### Welcome to my CS 807 - Interactive Hardware Blog\r\nI created this blog for two reasons:\r\n1. I needed a better way to submit my assignments to my instructor and\r\n2. I want to have a nice record of the work I've done as I will most likely regret not being able to find it sometime down the line. \r\n\r\n**Please Note: Everything here is published as public domain**\r\n\r\nI mean, copyrights suck -- like, hard. And, besides, there's probably nothing here worth copyrighting\r\nIf you **do** find anything here interesting and want to copy it, I'd appreciate some attribution,\r\nbut, hey, [it's not like I am going to come after you with a baseball-bat wearing a chicken mask or something.](hotlinemiami.com)\r\n\r\n***\r\n### Assignment 3: Doin' stuff with motors and servos / shift registers\r\nFor this assignment, we played around with the arduino and motors and shift registers (as the title\r\nwould suggest). \r\n\r\n***Part 1: DC Motor***\r\n\r\nFollowing the [Oomlaut ARDX Circ-03 tutorial](http://oomlout.com/a/products/ardx/circ-03/) for DC motors I wound up with this beautiful disaster:\r\n\r\n![](https://raw.github.com/trevortomesh/InteractiveHardware/fab20d3b0d0583027e5e4cb0d14532252c6e9780/assignments/a3/20140130_221143.jpg)\r\n\r\nThis set-up is very simple with with very simple code (once again, taken from the [CIRC-03 tutorial](http://oomlout.com/a/products/ardx/circ-03/): \r\n```C++\r\n/*     ———————————————————–\r\n*     |  Arduino Experimentation Kit Example Code               |\r\n*     |  CIRC-03 .: Spin Motor Spin :. (Transistor and Motor)   |\r\n*     ———————————————————–\r\n*\r\n* The Arduinos pins are great for driving LEDs however if you hook\r\n* up something that requires more power you will quickly break them.\r\n* To control bigger items we need the help of a transistor.\r\n* Here we will use a transistor to control a small toy motor\r\n*\r\n* http://tinyurl.com/d4wht7\r\n*\r\n*/\r\n\r\nint motorPin = 9;  // define the pin the motor is connected to\r\n                   // (if you use pin 9,10,11 or 3you can also control speed)\r\n\r\n/*\r\n* setup() – this function runs once when you turn your Arduino on\r\n* We set the motors pin to be an output (turning the pin high (+5v) or low (ground) (-))\r\n* rather than an input (checking whether a pin is high or low)\r\n*/\r\nvoid setup()\r\n{\r\npinMode(motorPin, OUTPUT);\r\n}\r\n\r\n/*\r\n* loop() – this function will start after setup finishes and then repeat\r\n* we call a function called motorOnThenOff()\r\n*/\r\n\r\nvoid loop()                     // run over and over again\r\n{\r\nmotorOnThenOff();\r\n//motorOnThenOffWithSpeed();\r\n//motorAcceleration();\r\n}\r\n\r\n/*\r\n* motorOnThenOff() – turns motor on then off\r\n* (notice this code is identical to the code we used for\r\n* the blinking LED)\r\n*/\r\nvoid motorOnThenOff(){\r\n  int onTime = 2500;  //the number of milliseconds for the motor to turn on for\r\n  int offTime = 1000; //the number of milliseconds for the motor to turn off for\r\n  \r\n  digitalWrite(motorPin, HIGH); // turns the motor On\r\n  delay(onTime);                // waits for onTime milliseconds\r\n  digitalWrite(motorPin, LOW);  // turns the motor Off\r\n  delay(offTime);               // waits for offTime milliseconds\r\n}\r\n\r\n/*\r\n* motorOnThenOffWithSpeed() – turns motor on then off but uses speed values as well\r\n* (notice this code is identical to the code we used for\r\n* the blinking LED)\r\n*/\r\nvoid motorOnThenOffWithSpeed(){\r\n  \r\n  int onSpeed = 200;  // a number between 0 (stopped) and 255 (full speed)\r\n  int onTime = 2500;  //the number of milliseconds for the motor to turn on for\r\n  \r\n  int offSpeed = 50;  // a number between 0 (stopped) and 255 (full speed)\r\n  int offTime = 1000; //the number of milliseconds for the motor to turn off for\r\n  \r\n  analogWrite(motorPin, onSpeed);   // turns the motor On\r\n  delay(onTime);                    // waits for onTime milliseconds\r\n  analogWrite(motorPin, offSpeed);  // turns the motor Off\r\n  delay(offTime);                   // waits for offTime milliseconds\r\n}\r\n\r\n/*\r\n* motorAcceleration() – accelerates the motor to full speed then\r\n* back down to zero\r\n*/\r\nvoid motorAcceleration(){\r\n  int delayTime = 50; //milliseconds between each speed step\r\n  \r\n  //Accelerates the motor\r\n  for(int i = 0; i < 256; i++){ //goes through each speed from 0 to 255\r\n    analogWrite(motorPin, i);   //sets the new speed\r\n    delay(delayTime);           // waits for delayTime milliseconds\r\n  }\r\n  \r\n  //Decelerates the motor\r\n  for(int i = 255; i >= 0; i--){ //goes through each speed from 255 to 0\r\n    analogWrite(motorPin, i);   //sets the new speed\r\n    delay(delayTime);           // waits for delayTime milliseconds\r\n  }\r\n}\r\n```\r\nIn a nut-shell, this code pulses a DC Motor that is connected to pin 9. It is nearly exactly like the \"blink code\" except with an analogWrite. \r\n\r\nI wanted to do something a little more interesting with this circuit, so I removed the resistor and replaced it with a photo-resistor:\r\n![](https://raw.github.com/trevortomesh/InteractiveHardware/fab20d3b0d0583027e5e4cb0d14532252c6e9780/assignments/a3/20140130_221254.jpg)\r\n\r\nIt may not look like much... because it really isn't, but there's some rather entertaining implications of replacing the regular resistor with a photo-resistor. When we normally think about \"autonomous agents\" that have the ability to \"sense\" their environment -- we tend to think of a three step process: \r\n\r\nSensing --> Processing --> Acting\r\n\r\nThat is, an agent senses a stimuli in its environment, makes a decision as to how to react and then acts upon it (or not, depending upon what sort of decision it makes). Had I wired the photo-resistor to an analog port and instructed the MCU to rotate the motor according to how much light was detected, that would be according to the sense-think-act model. However, I did not. Rather, I inserted the resistor directly into the circuit so that the motor speed would change as a result of the resistance of the photo-resistor! There is no \"processing involved\". This sort of machine is known as a [Braitenberg Vehicle](http://en.wikipedia.org/wiki/Braitenberg_vehicle). I could go on for hours about behavior-based robotics and how Braitenberg vehicles are awesome and what implication they have on the nature of the universe -- but will save that for another time. \r\n\r\n***Part 2: Servo***\r\n\r\nFor part 2, I followed [CIRC-04] (http://oomlout.com/a/products/ardx/circ-04/) of the ARDX kit to build a little servo-circuit that runs a boring little program: \r\n\r\n```C++\r\n// Sweep\r\n// by BARRAGAN\r\n\r\n#include <Servo.h>\r\n\r\nServo myservo;  // create servo object to control a servo\r\n                // a maximum of eight servo objects can be created\r\n\r\nint pos = 0;    // variable to store the servo position\r\n\r\nvoid setup()\r\n{\r\n  myservo.attach(9);  // attaches the servo on pin 9 to the servo object\r\n}\r\n\r\nvoid loop()\r\n{\r\n  for(pos = 0; pos < 180; pos += 1)  // goes from 0 degrees to 180 degrees\r\n  {                                  // in steps of 1 degree\r\n    myservo.write(pos);              // tell servo to go to position in variable 'pos'\r\n    delay(15);                       // waits 15ms for the servo to reach the position\r\n  }\r\n  for(pos = 180; pos>=1; pos-=1)     // goes from 180 degrees to 0 degrees\r\n  {                                \r\n    myservo.write(pos);              // tell servo to go to position in variable ‘pos’\r\n    delay(15);                       // waits 15ms for the servo to reach the position\r\n  }\r\n} \r\n```\r\n\r\nThe set-up: \r\n\r\n![](https://raw.github.com/trevortomesh/InteractiveHardware/fab20d3b0d0583027e5e4cb0d14532252c6e9780/assignments/a3/20140130_222729.jpg)\r\n\r\nNot too much interesting here. The code steps the servo through 180 degrees in one direction and then returns. However, I thought back to a project that I did as an undergraduate where I drove a physical pendulum with the oscillating signal from a simulated [squid-giant axon](http://adsabs.harvard.edu/abs/2010APS..MAR.K1013T) (the result of which will forever be pejoratively known as \"robo-squid\" at the University of Wisconsin - River Falls) -- which provided a it of inspiration.\r\n\r\nAnyhow, I decided that now might be a good time to, perhaps, re-visit the idea. The original \"robosquid\" code was written in python, so I decided to get my hands dirty with some python-serial communication. The resulting code: \r\n\r\n```Python\r\n#!/usr/bin/env python\r\nimport serial\r\n\r\npos=input(\"'H' or 'L'?   \")\r\n\r\n\r\nser = serial.Serial('/dev/ttyACM0', 9600)\r\n\r\nser.write(pos)\r\n```\r\nThis code, very simply, prompts the user for a value of 'H' or 'L' and, depending upon what the user selects, will write to the serial port that the arduino is located at. \r\n\r\nThe functional arduino test-code looks like this: \r\n\r\n```C++\r\n// Sweep\r\n// by BARRAGAN <http://barraganstudio.com> \r\n\r\n#include <Servo.h> \r\n \r\nServo myservo;  // create servo object to control a servo \r\n                // a maximum of eight servo objects can be created \r\n \r\nint pos = 0;    // variable to store the servo position \r\nint del = 15;\r\n \r\nvoid setup() \r\n{ \r\n  Serial.begin(9600);        // connect to the serial port\r\n  Serial.println(\"Arduino is ready\");\r\n  myservo.attach(9);  // attaches the servo on pin 9 to the servo object \r\n} \r\n \r\n \r\nvoid loop() \r\n{ \r\n  for(pos = 0; pos < 180; pos += 1)  // goes from 0 degrees to 180 degrees \r\n  {                                  // in steps of 1 degree \r\n    myservo.write(pos);              // tell servo to go to position in variable 'pos' \r\n    delay(del);                       // waits 15ms for the servo to reach the position \r\n  } \r\n  for(pos = 180; pos>=1; pos-=1)     // goes from 180 degrees to 0 degrees \r\n  {                                \r\n    myservo.write(pos);              // tell servo to go to position in variable 'pos' \r\n    delay(del);                       // waits 15ms for the servo to reach the position \r\n  } \r\n  \r\n    int serbyte = 0;\r\n    \r\n\r\n  serbyte = Serial.read();\r\n  // if the input is '-1' then there is no data\r\n  if (serbyte != -1)\r\n  {\r\n    if (serbyte == 'H')\r\n    {\r\n      Serial.write('H');\r\n      del = 5;\r\n    }\r\n    if (serbyte == 'L' )\r\n    {\r\n      Serial.write('L');\r\n    del = 15;\r\n    \r\n    }\r\n  \r\n  \r\n} \r\n}\r\n```\r\nIn a nutshell, given the user input of 'H' or 'L' the arduino will respond by either speeding up or slowing down. This is accomplished simply by changing the value of the delay (hence the variable _del_). This is very interesting because it allows for the servo to be controlled by python code running on the computer. There are a number of interesting applications for this (the resurrection of robosquid being one) including the ability to interact with the Blender Game Engine -- which uses Python as a scripting language. \r\n\r\n***Part 3: Shift Register***\r\n\r\n[CIRC-5](http://oomlout.com/a/products/ardx/circ-05/) involved using a shift register to run a set of 8 LED's off of just three pins.\r\n\r\nThe set-up:\r\n![](https://raw.github.com/trevortomesh/InteractiveHardware/gh-pages/assignments/a3/20140131_004956.jpg)\r\n\r\nYikes! And the code: \r\n\r\n```C++\r\n/*     ———————————————————\r\n*     |  Arduino Experimentation Kit Example Code             |\r\n*     |  CIRC-05 .: 8 More LEDs :. (74HC595 Shift Register)   |\r\n*     ———————————————————\r\n*\r\n* We have already controlled 8 LEDs however this does it in a slightly\r\n* different manner. Rather than using 8 pins we will use just three\r\n* and an additional chip.\r\n*\r\n*\r\n*/\r\n\r\n//Pin Definitions\r\n//The 74HC595 using a protocol called SPI (for more details http://www.arduino.cc/en/Tutorial/ShiftOut)\r\n//Which has three pins\r\nint data = 2;\r\nint clock = 3;\r\nint latch = 4;\r\n\r\n//Used for single LED manipulation\r\nint ledState = 0;\r\nconst int ON = HIGH;\r\nconst int OFF = LOW;\r\n                        \r\n\r\n/*\r\n* setup() – this function runs once when you turn your Arduino on\r\n* We set the three control pins to outputs\r\n*/\r\nvoid setup()\r\n{\r\n  pinMode(data, OUTPUT);\r\n  pinMode(clock, OUTPUT);  \r\n  pinMode(latch, OUTPUT);  \r\n}\r\n\r\n/*\r\n* loop() – this function will start after setup finishes and then repeat\r\n* we set which LEDs we want on then call a routine which sends the states to the 74HC595\r\n*/\r\nvoid loop()                     // run over and over again\r\n{\r\n  int delayTime = 100; //the number of milliseconds to delay between LED updates\r\n  for(int i = 0; i < 256; i++){\r\n   updateLEDs(i);\r\n   delay(delayTime);\r\n  }\r\n}\r\n\r\n/*\r\n* updateLEDs() - sends the LED states set in ledStates to the 74HC595\r\n* sequence\r\n*/\r\nvoid updateLEDs(int value){\r\n  digitalWrite(latch, LOW);     //Pulls the chips latch low\r\n  shiftOut(data, clock, MSBFIRST, value); //Shifts out the 8 bits to the shift register\r\n  digitalWrite(latch, HIGH);   //Pulls the latch high displaying the data\r\n}\r\n\r\n/*\r\n* updateLEDsLong() - sends the LED states set in ledStates to the 74HC595\r\n* sequence. Same as updateLEDs except the shifting out is done in software\r\n* so you can see what is happening.\r\n*/\r\nvoid updateLEDsLong(int value){\r\n  digitalWrite(latch, LOW);    //Pulls the chips latch low\r\n  for(int i = 0; i < 8; i++){  //Will repeat 8 times (once for each bit)\r\n  int bit = value & B10000000; //We use a \"bitmask\" to select only the eighth\r\n                               //bit in our number (the one we are addressing this time through\r\n  value = value << 1;          //we move our number up one bit value so next time bit 7 will be\r\n                               //bit 8 and we will do our math on it\r\n  if(bit == 128){digitalWrite(data, HIGH);} //if bit 8 is set then set our data pin high\r\n  else{digitalWrite(data, LOW);}            //if bit 8 is unset then set the data pin low\r\n  digitalWrite(clock, HIGH);                //the next three lines pulse the clock pin\r\n  delay(1);\r\n  digitalWrite(clock, LOW);\r\n  }\r\n  digitalWrite(latch, HIGH);  //pulls the latch high shifting our data into being displayed\r\n}\r\n\r\n//These are used in the bitwise math that we use to change individual LEDs\r\n//For more details http://en.wikipedia.org/wiki/Bitwise_operation\r\nint bits[] = {B00000001, B00000010, B00000100, B00001000, B00010000, B00100000, B01000000, B10000000};\r\nint masks[] = {B11111110, B11111101, B11111011, B11110111, B11101111, B11011111, B10111111, B01111111};\r\n/*\r\n* changeLED(int led, int state) - changes an individual LED\r\n* LEDs are 0 to 7 and state is either 0 - OFF or 1 - ON\r\n*/\r\nvoid changeLED(int led, int state){\r\n   ledState = ledState & masks[led];  //clears ledState of the bit we are addressing\r\n   if(state == ON){ledState = ledState | bits[led];} //if the bit is on we will add it to ledState\r\n   updateLEDs(ledState);              //send the new LED state to the shift register\r\n}\r\n```\r\nSo, this program just counts to 128 in binary using red LEDs. Certainly, we can do something more interesting with it!\r\n\r\n```C++\r\n/*     ---------------------------------------------------------\r\n *     |  Arduino Experimentation Kit Example Code             |\r\n *     |  CIRC-05 .: 8 More LEDs :. (74HC595 Shift Register)   |\r\n *     ---------------------------------------------------------\r\n * \r\n * We have already controlled 8 LEDs however this does it in a slightly\r\n * different manner. Rather than using 8 pins we will use just three\r\n * and an additional chip.\r\n *\r\n *\r\n */\r\n\r\n\r\n//Pin Definitions\r\n//Pin Definitions\r\n//The 74HC595 uses a serial communication \r\n//link which has three pins\r\nint data = 2; \r\nint clock = 3;\r\nint latch = 4;\r\n\r\n\r\n//Used for single LED manipulation\r\nint ledState = 0;\r\nconst int ON = HIGH;\r\nconst int OFF = LOW;\r\nint stateArray[]={1,1,0,0,1,0,1,1}; \r\nint newStateArray[8];\r\n/*\r\n * setup() - this function runs once when you turn your Arduino on\r\n * We set the three control pins to outputs\r\n */\r\nvoid setup()\r\n{\r\n  pinMode(data, OUTPUT);\r\n  pinMode(clock, OUTPUT);  \r\n  pinMode(latch, OUTPUT);  \r\n}\r\n\r\n\r\n\r\n/*\r\n * loop() - this function will start after setup finishes and then repeat\r\n * we set which LEDs we want on then call a routine which sends the states to the 74HC595\r\n */\r\nvoid loop()                     // run over and over again\r\n{\r\n  \r\n  \r\n // changeLED(1,1);\r\n  \r\n  \r\n    for(int i=0;i<=7;i++){\r\n    changeLED(i,stateArray[i]);    \r\n  }\r\n  \r\n  \r\n  for(int i=0;i<=7;i++){\r\n  \r\n    \r\n    \r\n    if(i == 0){\r\n      if(stateArray[7]==1 && stateArray[1]==0){\r\n        newStateArray[i]=1;\r\n       // changeLED(i,stateArray[i]);\r\n      }\r\n      \r\n     else if(stateArray[7]==0 && stateArray[1]==1){\r\n        newStateArray[i]=1;\r\n       // changeLED(i,stateArray[i]);\r\n      }\r\n      \r\n     else{\r\n      changeLED(i,0);\r\n      newStateArray[i]=0;\r\n      }\r\n    }\r\n    \r\n    if (i==7){\r\n            if(stateArray[0]==1 && stateArray[6]==0){\r\n        newStateArray[i]=1;\r\n     //   changeLED(i,stateArray[i]);\r\n      }\r\n      \r\n     else if(stateArray[0]==0 && stateArray[6]==1){\r\n        newStateArray[i]=1;\r\n     //   changeLED(i,stateArray[i]);\r\n      }\r\n      \r\n     else{\r\n      changeLED(i,0);\r\n      newStateArray[i]=0;\r\n      }\r\n    }\r\n      \r\n      \r\n  if(i != 0 && i != 7){    \r\n    \r\n    if(stateArray[i++]==1 && stateArray[i--]==0){\r\n      newStateArray[i]=1;\r\n    //changeLED(i,stateArray[i]);\r\n      \r\n    }\r\n    else if(stateArray[i--]==1 && stateArray[i++]==0){\r\n      newStateArray[i]=1;\r\n    //  changeLED(i,stateArray[i]);}\r\n  }\r\n    else{\r\n      changeLED(i,0);\r\n      newStateArray[i]=0;\r\n      }\r\n  \r\n  }\r\n    \r\n    \r\n    delay(1000);\r\n    \r\n      for(int i=0;i<=7;i++){\r\n    stateArray[i] = newStateArray[i]; \r\n  } \r\n  }\r\n}\r\n\r\n\r\n\r\n/*\r\n * updateLEDs() - sends the LED states set in ledStates to the 74HC595\r\n * sequence\r\n */\r\nvoid updateLEDs(int value){\r\n  digitalWrite(latch, LOW);     //Pulls the chips latch low\r\n  shiftOut(data, clock, MSBFIRST, value); //Shifts out the 8 bits to the shift register\r\n  digitalWrite(latch, HIGH);   //Pulls the latch high displaying the data\r\n}\r\n\r\n/*\r\n * updateLEDsLong() - sends the LED states set in ledStates to the 74HC595\r\n * sequence. Same as updateLEDs except the shifting out is done in software\r\n * so you can see what is happening.\r\n */ \r\nvoid updateLEDsLong(int value){\r\n  digitalWrite(latch, LOW);    //Pulls the chips latch low\r\n  for(int i = 0; i < 8; i++){  //Will repeat 8 times (once for each bit)\r\n  int bit = value & B10000000; //We use a \"bitmask\" to select only the eighth \r\n                               //bit in our number (the one we are addressing this time through\r\n  value = value << 1;          //we move our number up one bit value so next time bit 7 will be\r\n                               //bit 8 and we will do our math on it\r\n  if(bit == 128){digitalWrite(data, HIGH);} //if bit 8 is set then set our data pin high\r\n  else{digitalWrite(data, LOW);}            //if bit 8 is unset then set the data pin low\r\n  digitalWrite(clock, HIGH);                //the next three lines pulse the clock pin\r\n  delay(1);\r\n  digitalWrite(clock, LOW);\r\n  }\r\n  digitalWrite(latch, HIGH);  //pulls the latch high shifting our data into being displayed\r\n}\r\n\r\n\r\n//These are used in the bitwise math that we use to change individual LEDs\r\n//For more details http://en.wikipedia.org/wiki/Bitwise_operation\r\nint bits[] = {B00000001, B00000010, B00000100, B00001000, B00010000, B00100000, B01000000, B10000000};\r\nint masks[] = {B11111110, B11111101, B11111011, B11110111, B11101111, B11011111, B10111111, B01111111};\r\n/*\r\n * changeLED(int led, int state) - changes an individual LED \r\n * LEDs are 0 to 7 and state is either 0 - OFF or 1 - ON\r\n */\r\n void changeLED(int led, int state){\r\n   ledState = ledState & masks[led];  //clears ledState of the bit we are addressing\r\n   if(state == ON){ledState = ledState | bits[led];} //if the bit is on we will add it to ledState\r\n   updateLEDs(ledState);              //send the new LED state to the shift register\r\n }\r\n```\r\n\r\nHere I have changed to code to turn the LEDs into a 1-dimensional Conway's Game of Life with simplified rules (we are pretending that the lights are in a single-file rather than a matrix of 2 by 4): \r\n```\r\n1. If one (and only one) of your neighbors is ON, turn ON.\r\n2. Else turn OFF\r\n```\r\nConway's Life is a very interesting problem of mathematics and delves into questions of chaos, complexity theory, etc. This implamentation, while very small, has some surprisingly interesting results!\r\n\r\n### Assignment 4: Shift Registers (again), Bootloaders, Multiplexer and IR-Communication (sort of) \r\n\r\nThis lab was a huge pain for a number of reasons: \r\na) I forgot to get a second shift-register -- and had to hunt some down. \r\nb) Some of the instructions on tutorials I found were not particularly clear. \r\nc) Broken (?) parts. \r\nd) Uncooperative software\r\n\r\nI thought that I would bet ambitious with this assignment -- of course, that only ever leads to not actually getting the assignment done -- but, c'est la vie!\r\n\r\n***Part 1: Chained Shift-Registers***\r\nOkay, this first part was my bad. I totally spaced on getting a second shift-register and regretted it. Once I finally procured one -- it went unexpectedly smoothly.        \r\n\r\n\r\n![Good GOD! WHAT HAVE I DONE?!?!](http://farm8.staticflickr.com/7402/12686578973_7e846e713b.jpg)\r\n \r\nThis set-up makes use of two TI-SN74HC595N's and a very simple daisy-chain method (which I do not have time to draw-up a schematic for at the moment). \r\n\r\nWith this set-up I shamelessly used the shift-out method provided by the arduino core library -- because re-writing a library by hand is directly against my core beliefs ([Kopimism](http://en.wikipedia.org/wiki/Missionary_Church_of_Kopimism), if you must know). That and I am a) incredibly lazy and b) have no time. \r\n\r\nHowever, I was able to come up with some fun patterns: \r\n![](http://farm4.staticflickr.com/3745/12686548773_c287ac6b9b.jpg)\r\n\r\nThe standard \"binary counter\" (this time with more bits!)\r\n\r\n![](http://farm4.staticflickr.com/3802/12686982104_7df7503039.jpg)\r\n\r\nAnd, of course, the obligatory \"Cylon\" pattern -- not quite as interesting, but you \r\nget the idea. \r\n\r\n\r\n***Part 2: Flashing the Boot-loader***\r\nTo be honest -- I hated doing this. I was worried that I'd brick my board. But I followed the directions on [The Arduino website](http://arduino.cc/en/Tutorial/ArduinoISP#.Uwf-2niZi1E) and it worked out just fine. \r\n\r\n![](http://farm3.staticflickr.com/2872/12686739623_669fb05855.jpg)\r\n\r\nHere's an awful picture of my set-up. The link above provides the vague instruction \"On the Arduino Uno, you'll need to connect a 10 uF capacitor between reset and ground (after uploading the ArduinoISP sketch).\" \r\n\r\nSince I am using two Uno's, do I need to connect both to a 10uF capacitor? I wanted to be sure -- so I decided to hunt someone down for advice on #arduino on freenode. Of course, this question was met with sarcastic remarks about how I should use ISP, etc. etc. (typical) -- and I slunk away with a bruised ego and just guessed. Sigh.\r\n\r\nNow, despite this process being messy and potentially fatal -- there is good reason to do it. Bootloaders can become corrupted, out-dated, or even not-wanted. Furthermore, you can flash the bootloader with this method to make the arduino connect as a keyboard or some other USB HID. \r\n\r\nThe due and leonardo (and micro) have this USB HID capability built directly in -- all the user needs to do is to import the mouse and keyboard library. \r\n\r\n***Part 3: Multiplexer***\r\n\r\nPart 3 turned out to be a huge disappointment. My set-up: \r\n![](http://farm8.staticflickr.com/7338/12689007934_bc3eb3e7cf.jpg) \r\n\r\nI was very excited about this part of the assignment as there are so many things that you can do with these little chips. I hooked it up according to the spec. sheet (and made sure to plug the E-bar pin to ground -- as this chip is active when E-bar is low) -- but, alas no output. I tried switching it and reading values in instead, but the value would constantly oscillate no matter what configuration the pins were in. \r\n\r\nI therefore, had to conclude that either a) I have no idea what I am doing or b) There is a fault in the multiplexer. \r\n\r\nI've ordered a stack of multiplexers, but they've not yet showed up and so I am at a loss. :-/ \r\n\r\n\r\n***Part 4: LED Communication***\r\nVisible light communication is a very interesting \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}