{"name":"Interactive Hardware","tagline":"Interactive Hardware (CS 807) ","body":"### Welcome to my CS 807 - Interactive Hardware Blog\r\nI created this blog for two reasons:\r\n1. I needed a better way to submit my assignments to my instructor and\r\n2. I want to have a nice record of the work I've done as I will most likely regret not being able to find it sometime down the line. \r\n\r\n**Please Note: Everything here is published as public domain**\r\n\r\nI mean, copyrights suck -- like, hard. And, besides, there's probably nothing here worth copyrighting\r\nIf you **do** find anything here interesting and want to copy it, I'd appreciate some attribution,\r\nbut, hey, [it's not like I am going to come after you with a baseball-bat wearing a chicken mask or something.](hotlinemiami.com)\r\n\r\n------------------------------------------------------------------\r\n### Assignment 3: Doin' stuff with motors and servos / shift registers\r\nFor this assignment, we played around with the arduino and motors and shift registers (as the title\r\nwould suggest). \r\n\r\n***Part 1: DC Motor***\r\n\r\nFollowing the [Oomlaut ARDX Circ-03 tutorial](http://oomlout.com/a/products/ardx/circ-03/) for DC motors I wound up with this beautiful disaster:\r\n\r\n![](https://raw.github.com/trevortomesh/InteractiveHardware/fab20d3b0d0583027e5e4cb0d14532252c6e9780/assignments/a3/20140130_221143.jpg)\r\n\r\nThis set-up is very simple with with very simple code (once again, taken from the [CIRC-03 tutorial](http://oomlout.com/a/products/ardx/circ-03/): \r\n```C++\r\n/*     ———————————————————–\r\n*     |  Arduino Experimentation Kit Example Code               |\r\n*     |  CIRC-03 .: Spin Motor Spin :. (Transistor and Motor)   |\r\n*     ———————————————————–\r\n*\r\n* The Arduinos pins are great for driving LEDs however if you hook\r\n* up something that requires more power you will quickly break them.\r\n* To control bigger items we need the help of a transistor.\r\n* Here we will use a transistor to control a small toy motor\r\n*\r\n* http://tinyurl.com/d4wht7\r\n*\r\n*/\r\n\r\nint motorPin = 9;  // define the pin the motor is connected to\r\n                   // (if you use pin 9,10,11 or 3you can also control speed)\r\n\r\n/*\r\n* setup() – this function runs once when you turn your Arduino on\r\n* We set the motors pin to be an output (turning the pin high (+5v) or low (ground) (-))\r\n* rather than an input (checking whether a pin is high or low)\r\n*/\r\nvoid setup()\r\n{\r\npinMode(motorPin, OUTPUT);\r\n}\r\n\r\n/*\r\n* loop() – this function will start after setup finishes and then repeat\r\n* we call a function called motorOnThenOff()\r\n*/\r\n\r\nvoid loop()                     // run over and over again\r\n{\r\nmotorOnThenOff();\r\n//motorOnThenOffWithSpeed();\r\n//motorAcceleration();\r\n}\r\n\r\n/*\r\n* motorOnThenOff() – turns motor on then off\r\n* (notice this code is identical to the code we used for\r\n* the blinking LED)\r\n*/\r\nvoid motorOnThenOff(){\r\n  int onTime = 2500;  //the number of milliseconds for the motor to turn on for\r\n  int offTime = 1000; //the number of milliseconds for the motor to turn off for\r\n  \r\n  digitalWrite(motorPin, HIGH); // turns the motor On\r\n  delay(onTime);                // waits for onTime milliseconds\r\n  digitalWrite(motorPin, LOW);  // turns the motor Off\r\n  delay(offTime);               // waits for offTime milliseconds\r\n}\r\n\r\n/*\r\n* motorOnThenOffWithSpeed() – turns motor on then off but uses speed values as well\r\n* (notice this code is identical to the code we used for\r\n* the blinking LED)\r\n*/\r\nvoid motorOnThenOffWithSpeed(){\r\n  \r\n  int onSpeed = 200;  // a number between 0 (stopped) and 255 (full speed)\r\n  int onTime = 2500;  //the number of milliseconds for the motor to turn on for\r\n  \r\n  int offSpeed = 50;  // a number between 0 (stopped) and 255 (full speed)\r\n  int offTime = 1000; //the number of milliseconds for the motor to turn off for\r\n  \r\n  analogWrite(motorPin, onSpeed);   // turns the motor On\r\n  delay(onTime);                    // waits for onTime milliseconds\r\n  analogWrite(motorPin, offSpeed);  // turns the motor Off\r\n  delay(offTime);                   // waits for offTime milliseconds\r\n}\r\n\r\n/*\r\n* motorAcceleration() – accelerates the motor to full speed then\r\n* back down to zero\r\n*/\r\nvoid motorAcceleration(){\r\n  int delayTime = 50; //milliseconds between each speed step\r\n  \r\n  //Accelerates the motor\r\n  for(int i = 0; i < 256; i++){ //goes through each speed from 0 to 255\r\n    analogWrite(motorPin, i);   //sets the new speed\r\n    delay(delayTime);           // waits for delayTime milliseconds\r\n  }\r\n  \r\n  //Decelerates the motor\r\n  for(int i = 255; i >= 0; i--){ //goes through each speed from 255 to 0\r\n    analogWrite(motorPin, i);   //sets the new speed\r\n    delay(delayTime);           // waits for delayTime milliseconds\r\n  }\r\n}\r\n```\r\nIn a nut-shell, this code pulses a DC Motor that is connected to pin 9. It is nearly exactly like the \"blink code\" except with an analogWrite. \r\n\r\nI wanted to do something a little more interesting with this circuit, so I removed the resistor and replaced it with a photo-resistor:\r\n![](https://raw.github.com/trevortomesh/InteractiveHardware/fab20d3b0d0583027e5e4cb0d14532252c6e9780/assignments/a3/20140130_221254.jpg)\r\n\r\nIt may not look like much... because it really isn't, but there's some rather entertaining implications of replacing the regular resistor with a photo-resistor. When we normally think about \"autonomous agents\" that have the ability to \"sense\" their environment -- we tend to think of a three step process: \r\n\r\nSensing --> Processing --> Acting\r\n\r\nThat is, an agent senses a stimuli in its environment, makes a decision as to how to react and then acts upon it (or not, depending upon what sort of decision it makes). Had I wired the photo-resistor to an analog port and instructed the MCU to rotate the motor according to how much light was detected, that would be according to the sense-think-act model. However, I did not. Rather, I inserted the resistor directly into the circuit so that the motor speed would change as a result of the resistance of the photo-resistor! There is no \"processing involved\". This sort of machine is known as a [Braitenberg Vehicle](http://en.wikipedia.org/wiki/Braitenberg_vehicle). I could go on for hours about behavior-based robotics and how Braitenberg vehicles are awesome and what implication they have on the nature of the universe -- but will save that for another time. \r\n\r\n***Part 2: Servo***\r\n\r\nFor part 2, I followed [CIRC-04] (http://oomlout.com/a/products/ardx/circ-04/) of the ARDX kit to build a little servo-circuit that runs a boring little program: \r\n\r\n```C++\r\n// Sweep\r\n// by BARRAGAN\r\n\r\n#include <Servo.h>\r\n\r\nServo myservo;  // create servo object to control a servo\r\n                // a maximum of eight servo objects can be created\r\n\r\nint pos = 0;    // variable to store the servo position\r\n\r\nvoid setup()\r\n{\r\n  myservo.attach(9);  // attaches the servo on pin 9 to the servo object\r\n}\r\n\r\nvoid loop()\r\n{\r\n  for(pos = 0; pos < 180; pos += 1)  // goes from 0 degrees to 180 degrees\r\n  {                                  // in steps of 1 degree\r\n    myservo.write(pos);              // tell servo to go to position in variable 'pos'\r\n    delay(15);                       // waits 15ms for the servo to reach the position\r\n  }\r\n  for(pos = 180; pos>=1; pos-=1)     // goes from 180 degrees to 0 degrees\r\n  {                                \r\n    myservo.write(pos);              // tell servo to go to position in variable ‘pos’\r\n    delay(15);                       // waits 15ms for the servo to reach the position\r\n  }\r\n} \r\n```\r\n\r\nThe set-up: \r\n\r\n![](https://raw.github.com/trevortomesh/InteractiveHardware/fab20d3b0d0583027e5e4cb0d14532252c6e9780/assignments/a3/20140130_222729.jpg)\r\n\r\nNot too much interesting here. The code steps the servo through 180 degrees in one direction and then returns. At first I could not think of much interesting to do with this that would not suck up my entire week and get me in trouble with the Missus for not feeding the dog (I have an adorable chihuahua who would not look quite so adorable emaciated). However, I thought back to a project that I did as an undergraduate where I drove a physical pendulum with the oscillating signal from a simulated [squid-giant axon](http://adsabs.harvard.edu/abs/2010APS..MAR.K1013T) (the result of which will forever be pejoratively known as \"robo-squid\" at the University of Wisconsin - River Falls).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}